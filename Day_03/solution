#!/opt/perl/bin/perl

use 5.028;

use strict;
use warnings;
no  warnings 'syntax';

use experimental 'signatures';
use experimental 'lexical_subs';


#
# Part 1
#
# The gravity assist was successful, and you're well on your way to
# the Venus refuelling station. During the rush back on Earth, the
# fuel management system wasn't completely installed, so that's next
# on the priority list.
# 
# Opening the front panel reveals a jumble of wires. Specifically,
# two wires are connected to a central port and extend outward on a
# grid. You trace the path each wire takes as it leaves the central
# port, one wire per line of text (your puzzle input).
# 
# The wires twist and turn, but the two wires occasionally cross
# paths. To fix the circuit, you need to find the intersection point
# closest to the central port. Because the wires are on a grid, use
# the Manhattan distance for this measurement. While the wires do
# technically cross right at the central port where they both start,
# this point does not count, nor does a wire count as crossing with
# itself.
# 
# For example, if the first wire's path is R8,U5,L5,D3, then starting
# from the central port (o), it goes right 8, up 5, left 5, and finally
# down 3:
# 
#    ...........
#    ...........
#    ...........
#    ....+----+.
#    ....|....|.
#    ....|....|.
#    ....|....|.
#    .........|.
#    .o-------+.
#    ...........
# 
# Then, if the second wire's path is U7,R6,D4,L4, it goes up 7, right
# 6, down 4, and left 4:
# 
#    ...........
#    .+-----+...
#    .|.....|...
#    .|..+--X-+.
#    .|..|..|.|.
#    .|.-X--+.|.
#    .|..|....|.
#    .|.......|.
#    .o-------+.
#    ...........
# 
# These wires cross at two locations (marked X), but the lower-left
# one is closer to the central port: its distance is 3 + 3 = 6.
# 
# Here are a few more examples:
# 
#    R75,D30,R83,U83,L12,D49,R71,U7,L72
#    U62,R66,U55,R34,D71,R55,D58,R83 = distance 159
#    R98,U47,R26,D63,R33,U87,L62,D20,R33,U53,R51
#    U98,R91,D20,R16,D67,R40,U7,R15,U6,R7 = distance 135
# 
# What is the Manhattan distance from the central port to the closest
# intersection?
# 

#
# Part 2
#
# It turns out that this circuit is very timing-sensitive; you actually
# need to minimize the signal delay.
# 
# To do this, calculate the number of steps each wire takes to reach
# each intersection; choose the intersection where the sum of both
# wires' steps is lowest. If a wire visits a position on the grid
# multiple times, use the steps value from the first time it visits
# that position when calculating the total value of a specific
# intersection.
# 
# The number of steps a wire takes is the total number of grid squares
# the wire has entered to get to that location, including the
# intersection being considered. Again consider the example from
# above:
# 
#    ...........
#    .+-----+...
#    .|.....|...
#    .|..+--X-+.
#    .|..|..|.|.
#    .|.-X--+.|.
#    .|..|....|.
#    .|.......|.
#    .o-------+.
#    ...........
#    
# In the above example, the intersection closest to the central port is
# reached after 8+5+5+2 = 20 steps by the first wire and 7+6+4+3 = 20
# steps by the second wire for a total of 20+20 = 40 steps.
# 
# However, the top-right intersection is better: the first wire takes
# only 8+5+2 = 15 and the second wire takes only 7+6+2 = 15, a total
# of 15+15 = 30 steps.
# 
# Here are the best steps for the extra examples from above:
# 
#     R75,D30,R83,U83,L12,D49,R71,U7,L72
#     U62,R66,U55,R34,D71,R55,D58,R83 = 610 steps
#     R98,U47,R26,D63,R33,U87,L62,D20,R33,U53,R51
#     U98,R91,D20,R16,D67,R40,U7,R15,U6,R7 = 410 steps
# 
# What is the fewest combined steps the wires must take to reach an
# intersection?
#

my $X = 0;
my $Y = 1;

my $input = shift // "input";
open my $fh, "<", $input or die "open: $!";
my @wire1 = <$fh> =~ /[RLDU][0-9]+/g;
my @wire2 = <$fh> =~ /[RLDU][0-9]+/g;

#
# Trace a wire. Return two sets of sub sections, one set with the
# vertical wires, and one set with the horizontal wires. Register
# the endpoints of each wire.
#
my sub trace ($wire) {
    my $tip = [0, 0];    # Keep track of the 'tip' of the wire
    my $horizontal = [];
    my $vertical   = [];

    foreach my $section (@$wire) {
        my ($direction, $distance) = $section =~ /^([LRDU])([0-9]+)/
                         or die "Failed to parse $section";

        my $new_tip = [@$tip];
        $$new_tip [$X] += $distance if $direction eq 'R';
        $$new_tip [$X] -= $distance if $direction eq 'L';
        $$new_tip [$Y] += $distance if $direction eq 'U';
        $$new_tip [$Y] -= $distance if $direction eq 'D';

        push @$horizontal => [$$tip [$Y], $$tip [$X], $$new_tip [$X]]
                          if  $direction eq 'R';
        push @$horizontal => [$$tip [$Y], $$new_tip [$X], $$tip [$X]]
                          if  $direction eq 'L';
        push @$vertical   => [$$tip [$X], $$tip [$Y], $$new_tip [$Y]]
                          if  $direction eq 'U';
        push @$vertical   => [$$tip [$X], $$new_tip [$Y], $$tip [$Y]]
                          if  $direction eq 'D';

        $tip = $new_tip;
    }

    return ($horizontal, $vertical);
}

#
# Intersect a horizontal and a vertical wire. Return the distance
# from the origin (Manhattan distance), or undef if no intersection.
#
my sub intersect ($horizontal, $vertical) {
    #
    # The horizontal section will be of the form [y, x1, x2] (x1 < x2), while
    # the vertical section will be of the form [x, y1, y2] (y1 < y2). The
    # sections intersect if, and only if
    #    x1 <= x <= x2  and   y1 <= y <= y2
    #
    # In that case, the intersection point is (x, y), and the distance
    # to the origin is abs (x) + abs (y)
    #

    return $$horizontal [1] <= $$vertical   [0]                     &&
                               $$vertical   [0] <= $$horizontal [2] &&
           $$vertical   [1] <= $$horizontal [0]                     &&
                               $$horizontal [0] <= $$vertical   [2]
            ? abs ($$horizontal [0]) + abs ($$vertical [0])
            : undef;
}


my ($horizontal1, $vertical1) = trace \@wire1;
my ($horizontal2, $vertical2) = trace \@wire2;

#
# Now intersect each horizontal from one wire with each vertical from
# the other. Keep track of the nearest.
#
my $min = (1 << 63) - 1;

foreach my $h (@$horizontal1) {
    foreach my $v (@$vertical2) {
        my $dist = intersect $h, $v or next;
        $min = $dist if $dist < $min;
    }
}
foreach my $h (@$horizontal2) {
    foreach my $v (@$vertical1) {
        my $dist = intersect $h, $v or next;
        $min = $dist if $dist < $min;
    }
}

say "Solution 1: $min";

__END__
